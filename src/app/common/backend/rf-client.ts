/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IDataClient {
    getProjects(): Observable<ProjectEntity[]>;
    createProject(genericCreateDtoWithName: GenericCreateDtoWithName): Observable<ProjectEntity>;
    getProjectById(projectId: string): Observable<ProjectEntity>;
    getListsByProject(id: string): Observable<ListEntity[]>;
    getProgramsByProject(id: string): Observable<ProgramEntity[]>;
    getListById(id: string): Observable<ListEntity>;
    getProgramById(id: string): Observable<ProgramEntity>;
    getListItemsByList(id: string): Observable<ListItemEntity[]>;
    getProgramItemsByProgram(programId: string | undefined, id: string): Observable<ProgramItemEntity[]>;
    getTags(): Observable<TagEntity[]>;
    createTag(dto: TagCreateDto): Observable<TagEntity>;
    createList(createGenericDto: CreateGenericWithParentDto): Observable<ListEntity>;
    createProgram(createGenericDto: CreateGenericWithParentDto): Observable<ProgramEntity>;
    createTemporaryProgram(projectId: string): Observable<ProgramEntity>;
    getItem(id: string): Observable<ItemEntity>;
    getProgramItem(id: string): Observable<ProgramItemEntity>;
    createItems(createItemDtos: CreateItemDto[]): Observable<ItemEntity[]>;
    updateItem(updateItem: UpdateItemEntityDto): Observable<ItemEntity>;
    linkListItems(dto: CreateGenericWithParentAndItemsDto): Observable<ListItemEntity[]>;
    updateListItem(listItemToUpdateDto: UpdateListItemDto): Observable<ListItemEntity>;
    createListItemsWithNewItems(dto: GenericCreateWithParentAndNewItemsDto): Observable<ListItemEntity[]>;
    addImportSourceToEntity(dto: ImportSourceCreateDto): Observable<void>;
    addZoteroSourceToList(listId: string, zoteroCollectionId: string | null): Observable<void>;
    addTagsToEntities(dto: TagLinkDto): Observable<void>;
    linkProgramItems(dto: CreateGenericWithParentAndItemsDto): Observable<ProgramItemEntity[]>;
    updateProgramItem(dto: UpdateProgramItemDto): Observable<ProgramItemEntity>;
    updateItemFile(updateItemFile: UpdateItemFileDto): Observable<ItemEntity>;
    startProgramItem(programItemId: string): Observable<void>;
    endProgramItem(programItemId: string): Observable<void>;
    setProgramItemsUnread(dto: GenericManyIdsDto): Observable<void>;
    checkCurrentFileInfo(itemFileId: string): Observable<ItemFileEntity>;
    checkListItemsPdfFiles(listId: string): Observable<void>;
    deleteProgram(programId: string): Observable<void>;
    syncListWithZoteroSource(listId: string): Observable<void>;
    hello(name: string | null): Observable<HelloReply>;
}

@Injectable({
    providedIn: 'root'
})
export class DataClient implements IDataClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    getProjects(): Observable<ProjectEntity[]> {
        let url_ = this.baseUrl + "/v1/projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjects(<any>response_);
                } catch (e) {
                    return <Observable<ProjectEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjects(response: HttpResponseBase): Observable<ProjectEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectEntity[]>(<any>null);
    }

    createProject(genericCreateDtoWithName: GenericCreateDtoWithName): Observable<ProjectEntity> {
        let url_ = this.baseUrl + "/v1/projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(genericCreateDtoWithName);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProject(<any>response_);
                } catch (e) {
                    return <Observable<ProjectEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProject(response: HttpResponseBase): Observable<ProjectEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectEntity>(<any>null);
    }

    getProjectById(projectId: string): Observable<ProjectEntity> {
        let url_ = this.baseUrl + "/v1/projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectById(<any>response_);
                } catch (e) {
                    return <Observable<ProjectEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectById(response: HttpResponseBase): Observable<ProjectEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectEntity>(<any>null);
    }

    getListsByProject(id: string): Observable<ListEntity[]> {
        let url_ = this.baseUrl + "/v1/projects/{id}/lists";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListsByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListsByProject(<any>response_);
                } catch (e) {
                    return <Observable<ListEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListsByProject(response: HttpResponseBase): Observable<ListEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListEntity[]>(<any>null);
    }

    getProgramsByProject(id: string): Observable<ProgramEntity[]> {
        let url_ = this.baseUrl + "/v1/projects/{id}/programs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramsByProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramsByProject(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramsByProject(response: HttpResponseBase): Observable<ProgramEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity[]>(<any>null);
    }

    getListById(id: string): Observable<ListEntity> {
        let url_ = this.baseUrl + "/v1/lists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListById(<any>response_);
                } catch (e) {
                    return <Observable<ListEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetListById(response: HttpResponseBase): Observable<ListEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListEntity>(<any>null);
    }

    getProgramById(id: string): Observable<ProgramEntity> {
        let url_ = this.baseUrl + "/v1/programs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramById(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramById(response: HttpResponseBase): Observable<ProgramEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity>(<any>null);
    }

    getListItemsByList(id: string): Observable<ListItemEntity[]> {
        let url_ = this.baseUrl + "/v1/lists/{id}/listitems";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListItemsByList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListItemsByList(<any>response_);
                } catch (e) {
                    return <Observable<ListItemEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListItemsByList(response: HttpResponseBase): Observable<ListItemEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListItemEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemEntity[]>(<any>null);
    }

    getProgramItemsByProgram(programId: string | undefined, id: string): Observable<ProgramItemEntity[]> {
        let url_ = this.baseUrl + "/v1/programs/{id}/programitems?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramItemsByProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramItemsByProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramItemEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramItemEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramItemsByProgram(response: HttpResponseBase): Observable<ProgramItemEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramItemEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramItemEntity[]>(<any>null);
    }

    getTags(): Observable<TagEntity[]> {
        let url_ = this.baseUrl + "/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTags(<any>response_);
                } catch (e) {
                    return <Observable<TagEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTags(response: HttpResponseBase): Observable<TagEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TagEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagEntity[]>(<any>null);
    }

    createTag(dto: TagCreateDto): Observable<TagEntity> {
        let url_ = this.baseUrl + "/v1/tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<TagEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TagEntity>(<any>null);
    }

    createList(createGenericDto: CreateGenericWithParentDto): Observable<ListEntity> {
        let url_ = this.baseUrl + "/v1/lists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createGenericDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateList(<any>response_);
                } catch (e) {
                    return <Observable<ListEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateList(response: HttpResponseBase): Observable<ListEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListEntity>(<any>null);
    }

    createProgram(createGenericDto: CreateGenericWithParentDto): Observable<ProgramEntity> {
        let url_ = this.baseUrl + "/v1/programs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createGenericDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProgram(response: HttpResponseBase): Observable<ProgramEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity>(<any>null);
    }

    createTemporaryProgram(projectId: string): Observable<ProgramEntity> {
        let url_ = this.baseUrl + "/v1/programs/temporary/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemporaryProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemporaryProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTemporaryProgram(response: HttpResponseBase): Observable<ProgramEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity>(<any>null);
    }

    getItem(id: string): Observable<ItemEntity> {
        let url_ = this.baseUrl + "/v1/items/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItem(<any>response_);
                } catch (e) {
                    return <Observable<ItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetItem(response: HttpResponseBase): Observable<ItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemEntity>(<any>null);
    }

    getProgramItem(id: string): Observable<ProgramItemEntity> {
        let url_ = this.baseUrl + "/v1/programitems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProgramItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProgramItem(<any>response_);
                } catch (e) {
                    return <Observable<ProgramItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetProgramItem(response: HttpResponseBase): Observable<ProgramItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramItemEntity>(<any>null);
    }

    createItems(createItemDtos: CreateItemDto[]): Observable<ItemEntity[]> {
        let url_ = this.baseUrl + "/v1/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createItemDtos);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateItems(<any>response_);
                } catch (e) {
                    return <Observable<ItemEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateItems(response: HttpResponseBase): Observable<ItemEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ItemEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemEntity[]>(<any>null);
    }

    updateItem(updateItem: UpdateItemEntityDto): Observable<ItemEntity> {
        let url_ = this.baseUrl + "/v1/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateItem);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItem(<any>response_);
                } catch (e) {
                    return <Observable<ItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItem(response: HttpResponseBase): Observable<ItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemEntity>(<any>null);
    }

    linkListItems(dto: CreateGenericWithParentAndItemsDto): Observable<ListItemEntity[]> {
        let url_ = this.baseUrl + "/v1/listitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkListItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkListItems(<any>response_);
                } catch (e) {
                    return <Observable<ListItemEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processLinkListItems(response: HttpResponseBase): Observable<ListItemEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListItemEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemEntity[]>(<any>null);
    }

    updateListItem(listItemToUpdateDto: UpdateListItemDto): Observable<ListItemEntity> {
        let url_ = this.baseUrl + "/v1/listitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(listItemToUpdateDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateListItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateListItem(<any>response_);
                } catch (e) {
                    return <Observable<ListItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateListItem(response: HttpResponseBase): Observable<ListItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemEntity>(<any>null);
    }

    createListItemsWithNewItems(dto: GenericCreateWithParentAndNewItemsDto): Observable<ListItemEntity[]> {
        let url_ = this.baseUrl + "/v1/listitems/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateListItemsWithNewItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateListItemsWithNewItems(<any>response_);
                } catch (e) {
                    return <Observable<ListItemEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateListItemsWithNewItems(response: HttpResponseBase): Observable<ListItemEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ListItemEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemEntity[]>(<any>null);
    }

    addImportSourceToEntity(dto: ImportSourceCreateDto): Observable<void> {
        let url_ = this.baseUrl + "/v1/importsources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddImportSourceToEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddImportSourceToEntity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddImportSourceToEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    addZoteroSourceToList(listId: string, zoteroCollectionId: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/importsources/lists/{listId}/zotero/{zoteroCollectionId}";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
        if (zoteroCollectionId === undefined || zoteroCollectionId === null)
            throw new Error("The parameter 'zoteroCollectionId' must be defined.");
        url_ = url_.replace("{zoteroCollectionId}", encodeURIComponent("" + zoteroCollectionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddZoteroSourceToList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddZoteroSourceToList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddZoteroSourceToList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    addTagsToEntities(dto: TagLinkDto): Observable<void> {
        let url_ = this.baseUrl + "/v1/tags/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTagsToEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTagsToEntities(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddTagsToEntities(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    linkProgramItems(dto: CreateGenericWithParentAndItemsDto): Observable<ProgramItemEntity[]> {
        let url_ = this.baseUrl + "/v1/programitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkProgramItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkProgramItems(<any>response_);
                } catch (e) {
                    return <Observable<ProgramItemEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramItemEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processLinkProgramItems(response: HttpResponseBase): Observable<ProgramItemEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramItemEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramItemEntity[]>(<any>null);
    }

    updateProgramItem(dto: UpdateProgramItemDto): Observable<ProgramItemEntity> {
        let url_ = this.baseUrl + "/v1/programitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProgramItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProgramItem(<any>response_);
                } catch (e) {
                    return <Observable<ProgramItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProgramItem(response: HttpResponseBase): Observable<ProgramItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramItemEntity>(<any>null);
    }

    updateItemFile(updateItemFile: UpdateItemFileDto): Observable<ItemEntity> {
        let url_ = this.baseUrl + "/v1/itemfiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateItemFile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemFile(<any>response_);
                } catch (e) {
                    return <Observable<ItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemFile(response: HttpResponseBase): Observable<ItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemEntity>(<any>null);
    }

    startProgramItem(programItemId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/programitems/{programItemId}/start";
        if (programItemId === undefined || programItemId === null)
            throw new Error("The parameter 'programItemId' must be defined.");
        url_ = url_.replace("{programItemId}", encodeURIComponent("" + programItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartProgramItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartProgramItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processStartProgramItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    endProgramItem(programItemId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/programitems/{programItemId}/end";
        if (programItemId === undefined || programItemId === null)
            throw new Error("The parameter 'programItemId' must be defined.");
        url_ = url_.replace("{programItemId}", encodeURIComponent("" + programItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEndProgramItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEndProgramItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEndProgramItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    setProgramItemsUnread(dto: GenericManyIdsDto): Observable<void> {
        let url_ = this.baseUrl + "/v1/programitems/unread";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProgramItemsUnread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProgramItemsUnread(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetProgramItemsUnread(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    checkCurrentFileInfo(itemFileId: string): Observable<ItemFileEntity> {
        let url_ = this.baseUrl + "/v1/itemfiles/{itemFileId}/check";
        if (itemFileId === undefined || itemFileId === null)
            throw new Error("The parameter 'itemFileId' must be defined.");
        url_ = url_.replace("{itemFileId}", encodeURIComponent("" + itemFileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCurrentFileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCurrentFileInfo(<any>response_);
                } catch (e) {
                    return <Observable<ItemFileEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemFileEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCurrentFileInfo(response: HttpResponseBase): Observable<ItemFileEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ItemFileEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemFileEntity>(<any>null);
    }

    checkListItemsPdfFiles(listId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/lists/{listId}/check";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckListItemsPdfFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckListItemsPdfFiles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckListItemsPdfFiles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteProgram(programId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/programs/{programId}";
        if (programId === undefined || programId === null)
            throw new Error("The parameter 'programId' must be defined.");
        url_ = url_.replace("{programId}", encodeURIComponent("" + programId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProgram(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProgram(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    syncListWithZoteroSource(listId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/lists/{listId}/sync/zotero";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncListWithZoteroSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncListWithZoteroSource(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncListWithZoteroSource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    hello(name: string | null): Observable<HelloReply> {
        let url_ = this.baseUrl + "/v1/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHello(<any>response_);
                } catch (e) {
                    return <Observable<HelloReply>><any>_observableThrow(e);
                }
            } else
                return <Observable<HelloReply>><any>_observableThrow(response_);
        }));
    }

    protected processHello(response: HttpResponseBase): Observable<HelloReply> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HelloReply.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HelloReply>(<any>null);
    }
}

export interface IListClient {
    toggleListItemSkip(listItemId: string): Observable<void>;
    getListItem(listItemId: string): Observable<ListItemEntity>;
    deleteList(listId: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ListClient implements IListClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    toggleListItemSkip(listItemId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/listitems/{listItemId}/skip";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleListItemSkip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleListItemSkip(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processToggleListItemSkip(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getListItem(listItemId: string): Observable<ListItemEntity> {
        let url_ = this.baseUrl + "/v1/listitems/{listItemId}";
        if (listItemId === undefined || listItemId === null)
            throw new Error("The parameter 'listItemId' must be defined.");
        url_ = url_.replace("{listItemId}", encodeURIComponent("" + listItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListItem(<any>response_);
                } catch (e) {
                    return <Observable<ListItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetListItem(response: HttpResponseBase): Observable<ListItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListItemEntity>(<any>null);
    }

    deleteList(listId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/lists/{listId}";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IRootClient {
    welcome(): Observable<string>;
    shutDown(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RootClient implements IRootClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    welcome(): Observable<string> {
        let url_ = this.baseUrl + "/v1";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWelcome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWelcome(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processWelcome(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    shutDown(): Observable<void> {
        let url_ = this.baseUrl + "/v1/shutdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShutDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShutDown(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processShutDown(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IRoutineClient {
    createRoutineItemWithConditions(dto: RoutineItemWithConditionCreateDto): Observable<RoutineItemEntity>;
    generateProgramFromRoutine(routineId: string): Observable<ProgramEntity>;
    program(routineId: string): Observable<ProgramEntity>;
    getRoutine(routineId: string): Observable<RoutineEntity>;
    createRoutine(dtoWithName: GenericCreateDtoWithName): Observable<RoutineEntity>;
    listRoutines(): Observable<RoutineEntity[]>;
    listRoutinePrograms(): Observable<ProgramEntity[]>;
    getRoutineItem(routineItemId: string): Observable<RoutineItemEntity>;
    deleteRoutineItem(id: string): Observable<void>;
    deleteRoutine(id: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class RoutineClient implements IRoutineClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    createRoutineItemWithConditions(dto: RoutineItemWithConditionCreateDto): Observable<RoutineItemEntity> {
        let url_ = this.baseUrl + "/v1/routineitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRoutineItemWithConditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRoutineItemWithConditions(<any>response_);
                } catch (e) {
                    return <Observable<RoutineItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutineItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRoutineItemWithConditions(response: HttpResponseBase): Observable<RoutineItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoutineItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutineItemEntity>(<any>null);
    }

    generateProgramFromRoutine(routineId: string): Observable<ProgramEntity> {
        let url_ = this.baseUrl + "/v1/routines/{routineId}/generate";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateProgramFromRoutine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateProgramFromRoutine(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateProgramFromRoutine(response: HttpResponseBase): Observable<ProgramEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity>(<any>null);
    }

    program(routineId: string): Observable<ProgramEntity> {
        let url_ = this.baseUrl + "/v1/routines/{routineId}";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProgram(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProgram(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity>><any>_observableThrow(response_);
        }));
    }

    protected processProgram(response: HttpResponseBase): Observable<ProgramEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity>(<any>null);
    }

    getRoutine(routineId: string): Observable<RoutineEntity> {
        let url_ = this.baseUrl + "/v1/routines/{routineId}";
        if (routineId === undefined || routineId === null)
            throw new Error("The parameter 'routineId' must be defined.");
        url_ = url_.replace("{routineId}", encodeURIComponent("" + routineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoutine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoutine(<any>response_);
                } catch (e) {
                    return <Observable<RoutineEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutineEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoutine(response: HttpResponseBase): Observable<RoutineEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoutineEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutineEntity>(<any>null);
    }

    createRoutine(dtoWithName: GenericCreateDtoWithName): Observable<RoutineEntity> {
        let url_ = this.baseUrl + "/v1/routines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dtoWithName);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRoutine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRoutine(<any>response_);
                } catch (e) {
                    return <Observable<RoutineEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutineEntity>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRoutine(response: HttpResponseBase): Observable<RoutineEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoutineEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutineEntity>(<any>null);
    }

    listRoutines(): Observable<RoutineEntity[]> {
        let url_ = this.baseUrl + "/v1/routines";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListRoutines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListRoutines(<any>response_);
                } catch (e) {
                    return <Observable<RoutineEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutineEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processListRoutines(response: HttpResponseBase): Observable<RoutineEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoutineEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutineEntity[]>(<any>null);
    }

    listRoutinePrograms(): Observable<ProgramEntity[]> {
        let url_ = this.baseUrl + "/v1/routineprograms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListRoutinePrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListRoutinePrograms(<any>response_);
                } catch (e) {
                    return <Observable<ProgramEntity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProgramEntity[]>><any>_observableThrow(response_);
        }));
    }

    protected processListRoutinePrograms(response: HttpResponseBase): Observable<ProgramEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramEntity.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramEntity[]>(<any>null);
    }

    getRoutineItem(routineItemId: string): Observable<RoutineItemEntity> {
        let url_ = this.baseUrl + "/v1/routineitems/{routineItemId}";
        if (routineItemId === undefined || routineItemId === null)
            throw new Error("The parameter 'routineItemId' must be defined.");
        url_ = url_.replace("{routineItemId}", encodeURIComponent("" + routineItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoutineItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoutineItem(<any>response_);
                } catch (e) {
                    return <Observable<RoutineItemEntity>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoutineItemEntity>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoutineItem(response: HttpResponseBase): Observable<RoutineItemEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoutineItemEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoutineItemEntity>(<any>null);
    }

    deleteRoutineItem(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/routineitems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRoutineItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRoutineItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRoutineItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteRoutine(id: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/routines/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRoutine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRoutine(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRoutine(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IServiceClient {
    ifHasAnnotation(filePathDto: GenericFilePathDto): Observable<boolean>;
    outputPdfCommentsToMarkdown(dto: PdfToMarkdownDto): Observable<string>;
    recheckAllItemFilesForAnnotations(): Observable<number>;
    openPdfInViewer(filePath: string | null): Observable<void>;
    checkHealth(): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ServiceClient implements IServiceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    ifHasAnnotation(filePathDto: GenericFilePathDto): Observable<boolean> {
        let url_ = this.baseUrl + "/v1/service/pdf";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filePathDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIfHasAnnotation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIfHasAnnotation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIfHasAnnotation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    outputPdfCommentsToMarkdown(dto: PdfToMarkdownDto): Observable<string> {
        let url_ = this.baseUrl + "/v1/service/markdown";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutputPdfCommentsToMarkdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutputPdfCommentsToMarkdown(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processOutputPdfCommentsToMarkdown(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    recheckAllItemFilesForAnnotations(): Observable<number> {
        let url_ = this.baseUrl + "/v1/service/pdf/reset";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecheckAllItemFilesForAnnotations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecheckAllItemFilesForAnnotations(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRecheckAllItemFilesForAnnotations(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    openPdfInViewer(filePath: string | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/service/pdf/${filePath}";
        if (filePath === undefined || filePath === null)
            throw new Error("The parameter 'filePath' must be defined.");
        url_ = url_.replace("{filePath}", encodeURIComponent("" + filePath));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenPdfInViewer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenPdfInViewer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOpenPdfInViewer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    checkHealth(): Observable<boolean> {
        let url_ = this.baseUrl + "/v1/service/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckHealth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckHealth(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckHealth(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export interface IZoteroClient {
    getItem(itemKey: string | null): Observable<ZoteroReturnDataOfZoteroItem>;
    getAllZoteroCollections(): Observable<ZoteroReturnDataOfZoteroCollection[]>;
    getAllCollectionItems(collectionKey: string | null): Observable<ZoteroReturnDataOfZoteroItem[]>;
    addZoteroCollectionAsProjectList(collectionKey: string | null, projectId: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ZoteroClient implements IZoteroClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    getItem(itemKey: string | null): Observable<ZoteroReturnDataOfZoteroItem> {
        let url_ = this.baseUrl + "/v1/zotero/items/{itemKey}";
        if (itemKey === undefined || itemKey === null)
            throw new Error("The parameter 'itemKey' must be defined.");
        url_ = url_.replace("{itemKey}", encodeURIComponent("" + itemKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItem(<any>response_);
                } catch (e) {
                    return <Observable<ZoteroReturnDataOfZoteroItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoteroReturnDataOfZoteroItem>><any>_observableThrow(response_);
        }));
    }

    protected processGetItem(response: HttpResponseBase): Observable<ZoteroReturnDataOfZoteroItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZoteroReturnDataOfZoteroItem.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoteroReturnDataOfZoteroItem>(<any>null);
    }

    getAllZoteroCollections(): Observable<ZoteroReturnDataOfZoteroCollection[]> {
        let url_ = this.baseUrl + "/v1/zotero/collections";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllZoteroCollections(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllZoteroCollections(<any>response_);
                } catch (e) {
                    return <Observable<ZoteroReturnDataOfZoteroCollection[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoteroReturnDataOfZoteroCollection[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllZoteroCollections(response: HttpResponseBase): Observable<ZoteroReturnDataOfZoteroCollection[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZoteroReturnDataOfZoteroCollection.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoteroReturnDataOfZoteroCollection[]>(<any>null);
    }

    getAllCollectionItems(collectionKey: string | null): Observable<ZoteroReturnDataOfZoteroItem[]> {
        let url_ = this.baseUrl + "/v1/zotero/collections/{collectionKey}/items";
        if (collectionKey === undefined || collectionKey === null)
            throw new Error("The parameter 'collectionKey' must be defined.");
        url_ = url_.replace("{collectionKey}", encodeURIComponent("" + collectionKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCollectionItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCollectionItems(<any>response_);
                } catch (e) {
                    return <Observable<ZoteroReturnDataOfZoteroItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZoteroReturnDataOfZoteroItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCollectionItems(response: HttpResponseBase): Observable<ZoteroReturnDataOfZoteroItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ZoteroReturnDataOfZoteroItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZoteroReturnDataOfZoteroItem[]>(<any>null);
    }

    addZoteroCollectionAsProjectList(collectionKey: string | null, projectId: string): Observable<void> {
        let url_ = this.baseUrl + "/v1/zotero/collections/{collectionKey}/import-into/{projectId}";
        if (collectionKey === undefined || collectionKey === null)
            throw new Error("The parameter 'collectionKey' must be defined.");
        url_ = url_.replace("{collectionKey}", encodeURIComponent("" + collectionKey));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddZoteroCollectionAsProjectList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddZoteroCollectionAsProjectList(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddZoteroCollectionAsProjectList(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IBlankClient {
    hello(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class BlankClient implements IBlankClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:19862";
    }

    hello(): Observable<void> {
        let url_ = this.baseUrl + "/v1/blanks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHello(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processHello(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export abstract class AbstractEntity implements IAbstractEntity {
    id!: string;
    created!: Date;
    updated?: Date | null;

    constructor(data?: IAbstractEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>null;
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AbstractEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AbstractEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["created"] = this.created ? this.created.toISOString() : <any>null;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>null;
        return data; 
    }
}

export interface IAbstractEntity {
    id: string;
    created: Date;
    updated?: Date | null;
}

export class ProjectEntity extends AbstractEntity implements IProjectEntity {
    name!: string;
    lists?: ListEntity[] | null;
    programs?: ProgramEntity[] | null;
    tags?: TagEntity[] | null;

    constructor(data?: IProjectEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ListEntity.fromJS(item));
            }
            else {
                this.lists = <any>null;
            }
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramEntity.fromJS(item));
            }
            else {
                this.programs = <any>null;
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagEntity.fromJS(item));
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): ProjectEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IProjectEntity extends IAbstractEntity {
    name: string;
    lists?: ListEntity[] | null;
    programs?: ProgramEntity[] | null;
    tags?: TagEntity[] | null;
}

export class ListEntity extends AbstractEntity implements IListEntity {
    name?: string | null;
    listItems?: ListItemEntity[] | null;
    projectId!: string;
    order!: number;
    tags?: TagEntity[] | null;
    importSources?: ImportSourceEntity[] | null;

    constructor(data?: IListEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["listItems"])) {
                this.listItems = [] as any;
                for (let item of _data["listItems"])
                    this.listItems!.push(ListItemEntity.fromJS(item));
            }
            else {
                this.listItems = <any>null;
            }
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagEntity.fromJS(item));
            }
            else {
                this.tags = <any>null;
            }
            if (Array.isArray(_data["importSources"])) {
                this.importSources = [] as any;
                for (let item of _data["importSources"])
                    this.importSources!.push(ImportSourceEntity.fromJS(item));
            }
            else {
                this.importSources = <any>null;
            }
        }
    }

    static fromJS(data: any): ListEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.listItems)) {
            data["listItems"] = [];
            for (let item of this.listItems)
                data["listItems"].push(item.toJSON());
        }
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        if (Array.isArray(this.importSources)) {
            data["importSources"] = [];
            for (let item of this.importSources)
                data["importSources"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IListEntity extends IAbstractEntity {
    name?: string | null;
    listItems?: ListItemEntity[] | null;
    projectId: string;
    order: number;
    tags?: TagEntity[] | null;
    importSources?: ImportSourceEntity[] | null;
}

export class ListItemEntity extends AbstractEntity implements IListItemEntity {
    listId!: string;
    item?: ItemEntity | null;
    skip!: boolean;
    importance!: EImportance;
    order!: number;
    read!: boolean;
    lastRead?: Date | null;
    grasp!: number;
    tags?: TagEntity[] | null;

    constructor(data?: IListItemEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.listId = _data["listId"] !== undefined ? _data["listId"] : <any>null;
            this.item = _data["item"] ? ItemEntity.fromJS(_data["item"]) : <any>null;
            this.skip = _data["skip"] !== undefined ? _data["skip"] : <any>null;
            this.importance = _data["importance"] !== undefined ? _data["importance"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.read = _data["read"] !== undefined ? _data["read"] : <any>null;
            this.lastRead = _data["lastRead"] ? new Date(_data["lastRead"].toString()) : <any>null;
            this.grasp = _data["grasp"] !== undefined ? _data["grasp"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagEntity.fromJS(item));
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): ListItemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ListItemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId !== undefined ? this.listId : <any>null;
        data["item"] = this.item ? this.item.toJSON() : <any>null;
        data["skip"] = this.skip !== undefined ? this.skip : <any>null;
        data["importance"] = this.importance !== undefined ? this.importance : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["read"] = this.read !== undefined ? this.read : <any>null;
        data["lastRead"] = this.lastRead ? this.lastRead.toISOString() : <any>null;
        data["grasp"] = this.grasp !== undefined ? this.grasp : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IListItemEntity extends IAbstractEntity {
    listId: string;
    item?: ItemEntity | null;
    skip: boolean;
    importance: EImportance;
    order: number;
    read: boolean;
    lastRead?: Date | null;
    grasp: number;
    tags?: TagEntity[] | null;
}

export abstract class AbstractItemEntity extends AbstractEntity implements IAbstractItemEntity {
    lastRead?: Date | null;

    constructor(data?: IAbstractItemEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.lastRead = _data["lastRead"] ? new Date(_data["lastRead"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AbstractItemEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AbstractItemEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastRead"] = this.lastRead ? this.lastRead.toISOString() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractItemEntity extends IAbstractEntity {
    lastRead?: Date | null;
}

export class ItemEntity extends AbstractItemEntity implements IItemEntity {
    name?: string | null;
    abstract?: string | null;
    itemFiles?: ItemFileEntity[] | null;
    importSource?: ImportSourceEntity | null;
    tags?: TagEntity[] | null;
    conditionGenre?: EConditionGenre | null;

    constructor(data?: IItemEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.abstract = _data["abstract"] !== undefined ? _data["abstract"] : <any>null;
            if (Array.isArray(_data["itemFiles"])) {
                this.itemFiles = [] as any;
                for (let item of _data["itemFiles"])
                    this.itemFiles!.push(ItemFileEntity.fromJS(item));
            }
            else {
                this.itemFiles = <any>null;
            }
            this.importSource = _data["importSource"] ? ImportSourceEntity.fromJS(_data["importSource"]) : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagEntity.fromJS(item));
            }
            else {
                this.tags = <any>null;
            }
            this.conditionGenre = _data["conditionGenre"] !== undefined ? _data["conditionGenre"] : <any>null;
        }
    }

    static fromJS(data: any): ItemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ItemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["abstract"] = this.abstract !== undefined ? this.abstract : <any>null;
        if (Array.isArray(this.itemFiles)) {
            data["itemFiles"] = [];
            for (let item of this.itemFiles)
                data["itemFiles"].push(item.toJSON());
        }
        data["importSource"] = this.importSource ? this.importSource.toJSON() : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        data["conditionGenre"] = this.conditionGenre !== undefined ? this.conditionGenre : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IItemEntity extends IAbstractItemEntity {
    name?: string | null;
    abstract?: string | null;
    itemFiles?: ItemFileEntity[] | null;
    importSource?: ImportSourceEntity | null;
    tags?: TagEntity[] | null;
    conditionGenre?: EConditionGenre | null;
}

export class ItemFileEntity extends AbstractItemEntity implements IItemFileEntity {
    fileExtension?: string | null;
    fileName?: string | null;
    filePath?: string | null;
    fileFolder?: string | null;
    pages!: number;
    size?: string | null;
    fileModified!: Date;
    fileCreated!: Date;
    hasAnnotations!: boolean;
    lastChecked!: Date;
    itemId!: string;
    annotationCount!: number;

    constructor(data?: IItemFileEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileExtension = _data["fileExtension"] !== undefined ? _data["fileExtension"] : <any>null;
            this.fileName = _data["fileName"] !== undefined ? _data["fileName"] : <any>null;
            this.filePath = _data["filePath"] !== undefined ? _data["filePath"] : <any>null;
            this.fileFolder = _data["fileFolder"] !== undefined ? _data["fileFolder"] : <any>null;
            this.pages = _data["pages"] !== undefined ? _data["pages"] : <any>null;
            this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
            this.fileModified = _data["fileModified"] ? new Date(_data["fileModified"].toString()) : <any>null;
            this.fileCreated = _data["fileCreated"] ? new Date(_data["fileCreated"].toString()) : <any>null;
            this.hasAnnotations = _data["hasAnnotations"] !== undefined ? _data["hasAnnotations"] : <any>null;
            this.lastChecked = _data["lastChecked"] ? new Date(_data["lastChecked"].toString()) : <any>null;
            this.itemId = _data["itemId"] !== undefined ? _data["itemId"] : <any>null;
            this.annotationCount = _data["annotationCount"] !== undefined ? _data["annotationCount"] : <any>null;
        }
    }

    static fromJS(data: any): ItemFileEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ItemFileEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileExtension"] = this.fileExtension !== undefined ? this.fileExtension : <any>null;
        data["fileName"] = this.fileName !== undefined ? this.fileName : <any>null;
        data["filePath"] = this.filePath !== undefined ? this.filePath : <any>null;
        data["fileFolder"] = this.fileFolder !== undefined ? this.fileFolder : <any>null;
        data["pages"] = this.pages !== undefined ? this.pages : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["fileModified"] = this.fileModified ? this.fileModified.toISOString() : <any>null;
        data["fileCreated"] = this.fileCreated ? this.fileCreated.toISOString() : <any>null;
        data["hasAnnotations"] = this.hasAnnotations !== undefined ? this.hasAnnotations : <any>null;
        data["lastChecked"] = this.lastChecked ? this.lastChecked.toISOString() : <any>null;
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["annotationCount"] = this.annotationCount !== undefined ? this.annotationCount : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IItemFileEntity extends IAbstractItemEntity {
    fileExtension?: string | null;
    fileName?: string | null;
    filePath?: string | null;
    fileFolder?: string | null;
    pages: number;
    size?: string | null;
    fileModified: Date;
    fileCreated: Date;
    hasAnnotations: boolean;
    lastChecked: Date;
    itemId: string;
    annotationCount: number;
}

export class ImportSourceEntity extends AbstractItemEntity implements IImportSourceEntity {
    sourceUniqueId?: string | null;
    lastSynced?: Date | null;
    sourceLastModified?: Date | null;
    sourceType!: EImportSourceType;
    linkedEntityType!: EEntityType;
    itemId?: string | null;
    listId?: string | null;

    constructor(data?: IImportSourceEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sourceUniqueId = _data["sourceUniqueId"] !== undefined ? _data["sourceUniqueId"] : <any>null;
            this.lastSynced = _data["lastSynced"] ? new Date(_data["lastSynced"].toString()) : <any>null;
            this.sourceLastModified = _data["sourceLastModified"] ? new Date(_data["sourceLastModified"].toString()) : <any>null;
            this.sourceType = _data["sourceType"] !== undefined ? _data["sourceType"] : <any>null;
            this.linkedEntityType = _data["linkedEntityType"] !== undefined ? _data["linkedEntityType"] : <any>null;
            this.itemId = _data["itemId"] !== undefined ? _data["itemId"] : <any>null;
            this.listId = _data["listId"] !== undefined ? _data["listId"] : <any>null;
        }
    }

    static fromJS(data: any): ImportSourceEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSourceEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceUniqueId"] = this.sourceUniqueId !== undefined ? this.sourceUniqueId : <any>null;
        data["lastSynced"] = this.lastSynced ? this.lastSynced.toISOString() : <any>null;
        data["sourceLastModified"] = this.sourceLastModified ? this.sourceLastModified.toISOString() : <any>null;
        data["sourceType"] = this.sourceType !== undefined ? this.sourceType : <any>null;
        data["linkedEntityType"] = this.linkedEntityType !== undefined ? this.linkedEntityType : <any>null;
        data["itemId"] = this.itemId !== undefined ? this.itemId : <any>null;
        data["listId"] = this.listId !== undefined ? this.listId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IImportSourceEntity extends IAbstractItemEntity {
    sourceUniqueId?: string | null;
    lastSynced?: Date | null;
    sourceLastModified?: Date | null;
    sourceType: EImportSourceType;
    linkedEntityType: EEntityType;
    itemId?: string | null;
    listId?: string | null;
}

export enum EImportSourceType {
    ZOTERO = 0,
    TWEET = 1,
    POCKET = 2,
}

export enum EEntityType {
    ITEM = 0,
    PROGRAM_ITEM = 1,
    LIST_ITEM = 2,
    LIST = 3,
    PROGRAM = 4,
    PROJECT = 5,
    ITEMFILE = 6,
    TAG = 7,
}

export class TagEntity extends AbstractEntity implements ITagEntity {
    name?: string | null;
    type?: string | null;
    lastUsed?: Date | null;

    constructor(data?: ITagEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.lastUsed = _data["lastUsed"] ? new Date(_data["lastUsed"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TagEntity {
        data = typeof data === 'object' ? data : {};
        let result = new TagEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["lastUsed"] = this.lastUsed ? this.lastUsed.toISOString() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ITagEntity extends IAbstractEntity {
    name?: string | null;
    type?: string | null;
    lastUsed?: Date | null;
}

export enum EConditionGenre {
    Unspecified = 0,
    JournalArticle = 1,
    Monograph = 2,
}

export enum EImportance {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class ProgramEntity extends AbstractEntity implements IProgramEntity {
    name?: string | null;
    programItems?: ProgramItemEntity[] | null;
    order!: number;
    routineId?: string | null;
    isRoutineProgram!: boolean;
    isTemporary!: boolean;
    project?: ProjectEntity | null;
    projectId?: string | null;

    constructor(data?: IProgramEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["programItems"])) {
                this.programItems = [] as any;
                for (let item of _data["programItems"])
                    this.programItems!.push(ProgramItemEntity.fromJS(item));
            }
            else {
                this.programItems = <any>null;
            }
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.routineId = _data["routineId"] !== undefined ? _data["routineId"] : <any>null;
            this.isRoutineProgram = _data["isRoutineProgram"] !== undefined ? _data["isRoutineProgram"] : <any>null;
            this.isTemporary = _data["isTemporary"] !== undefined ? _data["isTemporary"] : <any>null;
            this.project = _data["project"] ? ProjectEntity.fromJS(_data["project"]) : <any>null;
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
        }
    }

    static fromJS(data: any): ProgramEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.programItems)) {
            data["programItems"] = [];
            for (let item of this.programItems)
                data["programItems"].push(item.toJSON());
        }
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["routineId"] = this.routineId !== undefined ? this.routineId : <any>null;
        data["isRoutineProgram"] = this.isRoutineProgram !== undefined ? this.isRoutineProgram : <any>null;
        data["isTemporary"] = this.isTemporary !== undefined ? this.isTemporary : <any>null;
        data["project"] = this.project ? this.project.toJSON() : <any>null;
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IProgramEntity extends IAbstractEntity {
    name?: string | null;
    programItems?: ProgramItemEntity[] | null;
    order: number;
    routineId?: string | null;
    isRoutineProgram: boolean;
    isTemporary: boolean;
    project?: ProjectEntity | null;
    projectId?: string | null;
}

export class ProgramItemEntity extends AbstractItemEntity implements IProgramItemEntity {
    name?: string | null;
    started?: Date | null;
    ended?: Date | null;
    timeUsed?: string | null;
    duration!: number;
    order!: number;
    read!: boolean;
    item?: ItemEntity | null;
    type!: EProgramItemType;
    strategy?: StrategyEntity | null;
    programId!: string;
    sourceListItemId?: string | null;
    tags?: TagEntity[] | null;

    constructor(data?: IProgramItemEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>null;
            this.ended = _data["ended"] ? new Date(_data["ended"].toString()) : <any>null;
            this.timeUsed = _data["timeUsed"] !== undefined ? _data["timeUsed"] : <any>null;
            this.duration = _data["duration"] !== undefined ? _data["duration"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.read = _data["read"] !== undefined ? _data["read"] : <any>null;
            this.item = _data["item"] ? ItemEntity.fromJS(_data["item"]) : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.strategy = _data["strategy"] ? StrategyEntity.fromJS(_data["strategy"]) : <any>null;
            this.programId = _data["programId"] !== undefined ? _data["programId"] : <any>null;
            this.sourceListItemId = _data["sourceListItemId"] !== undefined ? _data["sourceListItemId"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagEntity.fromJS(item));
            }
            else {
                this.tags = <any>null;
            }
        }
    }

    static fromJS(data: any): ProgramItemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramItemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["started"] = this.started ? this.started.toISOString() : <any>null;
        data["ended"] = this.ended ? this.ended.toISOString() : <any>null;
        data["timeUsed"] = this.timeUsed !== undefined ? this.timeUsed : <any>null;
        data["duration"] = this.duration !== undefined ? this.duration : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["read"] = this.read !== undefined ? this.read : <any>null;
        data["item"] = this.item ? this.item.toJSON() : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["strategy"] = this.strategy ? this.strategy.toJSON() : <any>null;
        data["programId"] = this.programId !== undefined ? this.programId : <any>null;
        data["sourceListItemId"] = this.sourceListItemId !== undefined ? this.sourceListItemId : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IProgramItemEntity extends IAbstractItemEntity {
    name?: string | null;
    started?: Date | null;
    ended?: Date | null;
    timeUsed?: string | null;
    duration: number;
    order: number;
    read: boolean;
    item?: ItemEntity | null;
    type: EProgramItemType;
    strategy?: StrategyEntity | null;
    programId: string;
    sourceListItemId?: string | null;
    tags?: TagEntity[] | null;
}

export enum EProgramItemType {
    ITEM = 0,
    BREAK = 1,
}

export class StrategyEntity extends AbstractEntity implements IStrategyEntity {
    pace!: number;
    purpose?: string | null;
    duration!: number;
    programItemId!: string;

    constructor(data?: IStrategyEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pace = _data["pace"] !== undefined ? _data["pace"] : <any>null;
            this.purpose = _data["purpose"] !== undefined ? _data["purpose"] : <any>null;
            this.duration = _data["duration"] !== undefined ? _data["duration"] : <any>null;
            this.programItemId = _data["programItemId"] !== undefined ? _data["programItemId"] : <any>null;
        }
    }

    static fromJS(data: any): StrategyEntity {
        data = typeof data === 'object' ? data : {};
        let result = new StrategyEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pace"] = this.pace !== undefined ? this.pace : <any>null;
        data["purpose"] = this.purpose !== undefined ? this.purpose : <any>null;
        data["duration"] = this.duration !== undefined ? this.duration : <any>null;
        data["programItemId"] = this.programItemId !== undefined ? this.programItemId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IStrategyEntity extends IAbstractEntity {
    pace: number;
    purpose?: string | null;
    duration: number;
    programItemId: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions?: { [key: string]: any; } | null;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.detail = _data["detail"] !== undefined ? _data["detail"] : <any>null;
            this.instance = _data["instance"] !== undefined ? _data["instance"] : <any>null;
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
            else {
                this.extensions = <any>null;
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["detail"] = this.detail !== undefined ? this.detail : <any>null;
        data["instance"] = this.instance !== undefined ? this.instance : <any>null;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key] !== undefined ? this.extensions[key] : <any>null;
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions?: { [key: string]: any; } | null;
}

export class GenericCreateDtoWithName implements IGenericCreateDtoWithName {
    name!: string;

    constructor(data?: IGenericCreateDtoWithName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): GenericCreateDtoWithName {
        data = typeof data === 'object' ? data : {};
        let result = new GenericCreateDtoWithName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IGenericCreateDtoWithName {
    name: string;
}

export class TagCreateDto implements ITagCreateDto {
    name!: string;
    type!: string;

    constructor(data?: ITagCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): TagCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface ITagCreateDto {
    name: string;
    type: string;
}

export class CreateGenericWithParentDto implements ICreateGenericWithParentDto {
    name!: string;
    parentId!: string;

    constructor(data?: ICreateGenericWithParentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.parentId = _data["parentId"] !== undefined ? _data["parentId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateGenericWithParentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGenericWithParentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        return data; 
    }
}

export interface ICreateGenericWithParentDto {
    name: string;
    parentId: string;
}

export class CreateItemDto implements ICreateItemDto {
    name?: string | null;
    filePath?: string | null;

    constructor(data?: ICreateItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.filePath = _data["filePath"] !== undefined ? _data["filePath"] : <any>null;
        }
    }

    static fromJS(data: any): CreateItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["filePath"] = this.filePath !== undefined ? this.filePath : <any>null;
        return data; 
    }
}

export interface ICreateItemDto {
    name?: string | null;
    filePath?: string | null;
}

export class CreateGenericWithParentAndItemsDto implements ICreateGenericWithParentAndItemsDto {
    parentId!: string;
    itemIds!: string[];
    allowDuplication?: boolean | null;

    constructor(data?: ICreateGenericWithParentAndItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.itemIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"] !== undefined ? _data["parentId"] : <any>null;
            if (Array.isArray(_data["itemIds"])) {
                this.itemIds = [] as any;
                for (let item of _data["itemIds"])
                    this.itemIds!.push(item);
            }
            else {
                this.itemIds = <any>null;
            }
            this.allowDuplication = _data["allowDuplication"] !== undefined ? _data["allowDuplication"] : <any>null;
        }
    }

    static fromJS(data: any): CreateGenericWithParentAndItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGenericWithParentAndItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        if (Array.isArray(this.itemIds)) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        data["allowDuplication"] = this.allowDuplication !== undefined ? this.allowDuplication : <any>null;
        return data; 
    }
}

export interface ICreateGenericWithParentAndItemsDto {
    parentId: string;
    itemIds: string[];
    allowDuplication?: boolean | null;
}

export class GenericCreateWithParentAndNewItemsDto implements IGenericCreateWithParentAndNewItemsDto {
    parentId!: string;
    createItemDtos!: CreateItemDto[];

    constructor(data?: IGenericCreateWithParentAndNewItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createItemDtos = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"] !== undefined ? _data["parentId"] : <any>null;
            if (Array.isArray(_data["createItemDtos"])) {
                this.createItemDtos = [] as any;
                for (let item of _data["createItemDtos"])
                    this.createItemDtos!.push(CreateItemDto.fromJS(item));
            }
            else {
                this.createItemDtos = <any>null;
            }
        }
    }

    static fromJS(data: any): GenericCreateWithParentAndNewItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenericCreateWithParentAndNewItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId !== undefined ? this.parentId : <any>null;
        if (Array.isArray(this.createItemDtos)) {
            data["createItemDtos"] = [];
            for (let item of this.createItemDtos)
                data["createItemDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGenericCreateWithParentAndNewItemsDto {
    parentId: string;
    createItemDtos: CreateItemDto[];
}

export class ImportSourceCreateDto implements IImportSourceCreateDto {
    sourceType!: EImportSourceType;
    linkedEntityType!: EEntityType;
    sourceUniqueId!: string;
    linkedItemId!: string;

    constructor(data?: IImportSourceCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceType = _data["sourceType"] !== undefined ? _data["sourceType"] : <any>null;
            this.linkedEntityType = _data["linkedEntityType"] !== undefined ? _data["linkedEntityType"] : <any>null;
            this.sourceUniqueId = _data["sourceUniqueId"] !== undefined ? _data["sourceUniqueId"] : <any>null;
            this.linkedItemId = _data["linkedItemId"] !== undefined ? _data["linkedItemId"] : <any>null;
        }
    }

    static fromJS(data: any): ImportSourceCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportSourceCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceType"] = this.sourceType !== undefined ? this.sourceType : <any>null;
        data["linkedEntityType"] = this.linkedEntityType !== undefined ? this.linkedEntityType : <any>null;
        data["sourceUniqueId"] = this.sourceUniqueId !== undefined ? this.sourceUniqueId : <any>null;
        data["linkedItemId"] = this.linkedItemId !== undefined ? this.linkedItemId : <any>null;
        return data; 
    }
}

export interface IImportSourceCreateDto {
    sourceType: EImportSourceType;
    linkedEntityType: EEntityType;
    sourceUniqueId: string;
    linkedItemId: string;
}

export class TagLinkDto implements ITagLinkDto {
    tagIds!: string[];
    entityIds!: string[];
    entityType!: EEntityType;

    constructor(data?: ITagLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tagIds = [];
            this.entityIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
            else {
                this.tagIds = <any>null;
            }
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            else {
                this.entityIds = <any>null;
            }
            this.entityType = _data["entityType"] !== undefined ? _data["entityType"] : <any>null;
        }
    }

    static fromJS(data: any): TagLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new TagLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        data["entityType"] = this.entityType !== undefined ? this.entityType : <any>null;
        return data; 
    }
}

export interface ITagLinkDto {
    tagIds: string[];
    entityIds: string[];
    entityType: EEntityType;
}

export class UpdateItemEntityDto extends AbstractItemEntity implements IUpdateItemEntityDto {
    name?: string | null;
    listItems?: ListItemEntity[] | null;
    programItems?: ProgramItemEntity[] | null;

    constructor(data?: IUpdateItemEntityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["listItems"])) {
                this.listItems = [] as any;
                for (let item of _data["listItems"])
                    this.listItems!.push(ListItemEntity.fromJS(item));
            }
            else {
                this.listItems = <any>null;
            }
            if (Array.isArray(_data["programItems"])) {
                this.programItems = [] as any;
                for (let item of _data["programItems"])
                    this.programItems!.push(ProgramItemEntity.fromJS(item));
            }
            else {
                this.programItems = <any>null;
            }
        }
    }

    static fromJS(data: any): UpdateItemEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateItemEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.listItems)) {
            data["listItems"] = [];
            for (let item of this.listItems)
                data["listItems"].push(item.toJSON());
        }
        if (Array.isArray(this.programItems)) {
            data["programItems"] = [];
            for (let item of this.programItems)
                data["programItems"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateItemEntityDto extends IAbstractItemEntity {
    name?: string | null;
    listItems?: ListItemEntity[] | null;
    programItems?: ProgramItemEntity[] | null;
}

export class UpdateItemFileDto extends AbstractItemEntity implements IUpdateItemFileDto {
    filePath?: string | null;
    pages!: number;
    size!: number;
    hasAnnotations!: boolean;
    fileModified!: Date;
    fileCreated!: Date;

    constructor(data?: IUpdateItemFileDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.filePath = _data["filePath"] !== undefined ? _data["filePath"] : <any>null;
            this.pages = _data["pages"] !== undefined ? _data["pages"] : <any>null;
            this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
            this.hasAnnotations = _data["hasAnnotations"] !== undefined ? _data["hasAnnotations"] : <any>null;
            this.fileModified = _data["fileModified"] ? new Date(_data["fileModified"].toString()) : <any>null;
            this.fileCreated = _data["fileCreated"] ? new Date(_data["fileCreated"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UpdateItemFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateItemFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filePath"] = this.filePath !== undefined ? this.filePath : <any>null;
        data["pages"] = this.pages !== undefined ? this.pages : <any>null;
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["hasAnnotations"] = this.hasAnnotations !== undefined ? this.hasAnnotations : <any>null;
        data["fileModified"] = this.fileModified ? this.fileModified.toISOString() : <any>null;
        data["fileCreated"] = this.fileCreated ? this.fileCreated.toISOString() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateItemFileDto extends IAbstractItemEntity {
    filePath?: string | null;
    pages: number;
    size: number;
    hasAnnotations: boolean;
    fileModified: Date;
    fileCreated: Date;
}

export class UpdateListItemDto extends AbstractItemEntity implements IUpdateListItemDto {
    listId!: string;
    importance!: EImportance;
    order!: number;

    constructor(data?: IUpdateListItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.listId = _data["listId"] !== undefined ? _data["listId"] : <any>null;
            this.importance = _data["importance"] !== undefined ? _data["importance"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateListItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateListItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId !== undefined ? this.listId : <any>null;
        data["importance"] = this.importance !== undefined ? this.importance : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateListItemDto extends IAbstractItemEntity {
    listId: string;
    importance: EImportance;
    order: number;
}

export class UpdateProgramItemDto extends AbstractItemEntity implements IUpdateProgramItemDto {
    name?: string | null;
    started?: Date | null;
    ended?: Date | null;
    timeUsed?: string | null;
    duration!: number;
    order!: number;
    read!: boolean;
    type!: EProgramItemType;

    constructor(data?: IUpdateProgramItemDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>null;
            this.ended = _data["ended"] ? new Date(_data["ended"].toString()) : <any>null;
            this.timeUsed = _data["timeUsed"] !== undefined ? _data["timeUsed"] : <any>null;
            this.duration = _data["duration"] !== undefined ? _data["duration"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.read = _data["read"] !== undefined ? _data["read"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateProgramItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProgramItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["started"] = this.started ? this.started.toISOString() : <any>null;
        data["ended"] = this.ended ? this.ended.toISOString() : <any>null;
        data["timeUsed"] = this.timeUsed !== undefined ? this.timeUsed : <any>null;
        data["duration"] = this.duration !== undefined ? this.duration : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["read"] = this.read !== undefined ? this.read : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateProgramItemDto extends IAbstractItemEntity {
    name?: string | null;
    started?: Date | null;
    ended?: Date | null;
    timeUsed?: string | null;
    duration: number;
    order: number;
    read: boolean;
    type: EProgramItemType;
}

export class GenericManyIdsDto implements IGenericManyIdsDto {
    ids!: string[];

    constructor(data?: IGenericManyIdsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            else {
                this.ids = <any>null;
            }
        }
    }

    static fromJS(data: any): GenericManyIdsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenericManyIdsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IGenericManyIdsDto {
    ids: string[];
}

export class HelloReply implements IHelloReply {
    message?: string | null;

    constructor(data?: IHelloReply) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): HelloReply {
        data = typeof data === 'object' ? data : {};
        let result = new HelloReply();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data; 
    }
}

export interface IHelloReply {
    message?: string | null;
}

export class RoutineItemEntity extends AbstractEntity implements IRoutineItemEntity {
    name!: string;
    conditions!: RoutineItemConditionEntity[];
    order!: number;
    sourceLists!: ListEntity[];
    routineId!: string;

    constructor(data?: IRoutineItemEntity) {
        super(data);
        if (!data) {
            this.conditions = [];
            this.sourceLists = [];
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(RoutineItemConditionEntity.fromJS(item));
            }
            else {
                this.conditions = <any>null;
            }
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            if (Array.isArray(_data["sourceLists"])) {
                this.sourceLists = [] as any;
                for (let item of _data["sourceLists"])
                    this.sourceLists!.push(ListEntity.fromJS(item));
            }
            else {
                this.sourceLists = <any>null;
            }
            this.routineId = _data["routineId"] !== undefined ? _data["routineId"] : <any>null;
        }
    }

    static fromJS(data: any): RoutineItemEntity {
        data = typeof data === 'object' ? data : {};
        let result = new RoutineItemEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["order"] = this.order !== undefined ? this.order : <any>null;
        if (Array.isArray(this.sourceLists)) {
            data["sourceLists"] = [];
            for (let item of this.sourceLists)
                data["sourceLists"].push(item.toJSON());
        }
        data["routineId"] = this.routineId !== undefined ? this.routineId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IRoutineItemEntity extends IAbstractEntity {
    name: string;
    conditions: RoutineItemConditionEntity[];
    order: number;
    sourceLists: ListEntity[];
    routineId: string;
}

export class RoutineItemConditionEntity extends AbstractEntity implements IRoutineItemConditionEntity {
    type!: EConditionType;
    order!: number;
    value!: number;
    genre!: EConditionGenre;
    threshold?: number | null;
    descOrder?: boolean | null;

    constructor(data?: IRoutineItemConditionEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.order = _data["order"] !== undefined ? _data["order"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.genre = _data["genre"] !== undefined ? _data["genre"] : <any>null;
            this.threshold = _data["threshold"] !== undefined ? _data["threshold"] : <any>null;
            this.descOrder = _data["descOrder"] !== undefined ? _data["descOrder"] : <any>null;
        }
    }

    static fromJS(data: any): RoutineItemConditionEntity {
        data = typeof data === 'object' ? data : {};
        let result = new RoutineItemConditionEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["order"] = this.order !== undefined ? this.order : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["genre"] = this.genre !== undefined ? this.genre : <any>null;
        data["threshold"] = this.threshold !== undefined ? this.threshold : <any>null;
        data["descOrder"] = this.descOrder !== undefined ? this.descOrder : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IRoutineItemConditionEntity extends IAbstractEntity {
    type: EConditionType;
    order: number;
    value: number;
    genre: EConditionGenre;
    threshold?: number | null;
    descOrder?: boolean | null;
}

export enum EConditionType {
    Item = 0,
    Time = 1,
    Priority = 2,
    Genre = 3,
    Relevance = 4,
    Pages = 5,
}

export class RoutineItemWithConditionCreateDto implements IRoutineItemWithConditionCreateDto {
    conditionCreateDtos!: ConditionCreateDto[];
    sourceListIds!: string[];
    routineId!: string;
    routineName!: string;

    constructor(data?: IRoutineItemWithConditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.conditionCreateDtos = [];
            this.sourceListIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["conditionCreateDtos"])) {
                this.conditionCreateDtos = [] as any;
                for (let item of _data["conditionCreateDtos"])
                    this.conditionCreateDtos!.push(ConditionCreateDto.fromJS(item));
            }
            else {
                this.conditionCreateDtos = <any>null;
            }
            if (Array.isArray(_data["sourceListIds"])) {
                this.sourceListIds = [] as any;
                for (let item of _data["sourceListIds"])
                    this.sourceListIds!.push(item);
            }
            else {
                this.sourceListIds = <any>null;
            }
            this.routineId = _data["routineId"] !== undefined ? _data["routineId"] : <any>null;
            this.routineName = _data["routineName"] !== undefined ? _data["routineName"] : <any>null;
        }
    }

    static fromJS(data: any): RoutineItemWithConditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoutineItemWithConditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditionCreateDtos)) {
            data["conditionCreateDtos"] = [];
            for (let item of this.conditionCreateDtos)
                data["conditionCreateDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.sourceListIds)) {
            data["sourceListIds"] = [];
            for (let item of this.sourceListIds)
                data["sourceListIds"].push(item);
        }
        data["routineId"] = this.routineId !== undefined ? this.routineId : <any>null;
        data["routineName"] = this.routineName !== undefined ? this.routineName : <any>null;
        return data; 
    }
}

export interface IRoutineItemWithConditionCreateDto {
    conditionCreateDtos: ConditionCreateDto[];
    sourceListIds: string[];
    routineId: string;
    routineName: string;
}

export class ConditionCreateDto implements IConditionCreateDto {
    type!: EConditionType;
    value!: number;
    genre!: EConditionGenre;

    constructor(data?: IConditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.genre = _data["genre"] !== undefined ? _data["genre"] : <any>null;
        }
    }

    static fromJS(data: any): ConditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["genre"] = this.genre !== undefined ? this.genre : <any>null;
        return data; 
    }
}

export interface IConditionCreateDto {
    type: EConditionType;
    value: number;
    genre: EConditionGenre;
}

export class RoutineEntity extends AbstractEntity implements IRoutineEntity {
    name?: string | null;
    routineItems?: RoutineItemEntity[] | null;
    program?: ProgramEntity | null;
    lastUsed?: Date | null;

    constructor(data?: IRoutineEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["routineItems"])) {
                this.routineItems = [] as any;
                for (let item of _data["routineItems"])
                    this.routineItems!.push(RoutineItemEntity.fromJS(item));
            }
            else {
                this.routineItems = <any>null;
            }
            this.program = _data["program"] ? ProgramEntity.fromJS(_data["program"]) : <any>null;
            this.lastUsed = _data["lastUsed"] ? new Date(_data["lastUsed"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): RoutineEntity {
        data = typeof data === 'object' ? data : {};
        let result = new RoutineEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.routineItems)) {
            data["routineItems"] = [];
            for (let item of this.routineItems)
                data["routineItems"].push(item.toJSON());
        }
        data["program"] = this.program ? this.program.toJSON() : <any>null;
        data["lastUsed"] = this.lastUsed ? this.lastUsed.toISOString() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IRoutineEntity extends IAbstractEntity {
    name?: string | null;
    routineItems?: RoutineItemEntity[] | null;
    program?: ProgramEntity | null;
    lastUsed?: Date | null;
}

export class GenericFilePathDto implements IGenericFilePathDto {
    filePath?: string | null;

    constructor(data?: IGenericFilePathDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filePath = _data["filePath"] !== undefined ? _data["filePath"] : <any>null;
        }
    }

    static fromJS(data: any): GenericFilePathDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenericFilePathDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filePath"] = this.filePath !== undefined ? this.filePath : <any>null;
        return data; 
    }
}

export interface IGenericFilePathDto {
    filePath?: string | null;
}

export class PdfToMarkdownDto implements IPdfToMarkdownDto {
    pdfPaths!: string[];
    markdownPath!: string;
    notesTitle!: string;

    constructor(data?: IPdfToMarkdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.pdfPaths = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["pdfPaths"])) {
                this.pdfPaths = [] as any;
                for (let item of _data["pdfPaths"])
                    this.pdfPaths!.push(item);
            }
            else {
                this.pdfPaths = <any>null;
            }
            this.markdownPath = _data["markdownPath"] !== undefined ? _data["markdownPath"] : <any>null;
            this.notesTitle = _data["notesTitle"] !== undefined ? _data["notesTitle"] : <any>null;
        }
    }

    static fromJS(data: any): PdfToMarkdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfToMarkdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.pdfPaths)) {
            data["pdfPaths"] = [];
            for (let item of this.pdfPaths)
                data["pdfPaths"].push(item);
        }
        data["markdownPath"] = this.markdownPath !== undefined ? this.markdownPath : <any>null;
        data["notesTitle"] = this.notesTitle !== undefined ? this.notesTitle : <any>null;
        return data; 
    }
}

export interface IPdfToMarkdownDto {
    pdfPaths: string[];
    markdownPath: string;
    notesTitle: string;
}

export class ZoteroReturnDataOfZoteroItem implements IZoteroReturnDataOfZoteroItem {
    key!: string;
    version!: number;
    library!: ZoteroLibrary;
    links!: LinkCollection;
    meta!: Meta;
    data!: ZoteroItem;

    constructor(data?: IZoteroReturnDataOfZoteroItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.library = new ZoteroLibrary();
            this.links = new LinkCollection();
            this.meta = new Meta();
            this.data = new ZoteroItem();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.library = _data["library"] ? ZoteroLibrary.fromJS(_data["library"]) : new ZoteroLibrary();
            this.links = _data["links"] ? LinkCollection.fromJS(_data["links"]) : new LinkCollection();
            this.meta = _data["meta"] ? Meta.fromJS(_data["meta"]) : new Meta();
            this.data = _data["data"] ? ZoteroItem.fromJS(_data["data"]) : new ZoteroItem();
        }
    }

    static fromJS(data: any): ZoteroReturnDataOfZoteroItem {
        data = typeof data === 'object' ? data : {};
        let result = new ZoteroReturnDataOfZoteroItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["library"] = this.library ? this.library.toJSON() : <any>null;
        data["links"] = this.links ? this.links.toJSON() : <any>null;
        data["meta"] = this.meta ? this.meta.toJSON() : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IZoteroReturnDataOfZoteroItem {
    key: string;
    version: number;
    library: ZoteroLibrary;
    links: LinkCollection;
    meta: Meta;
    data: ZoteroItem;
}

export class ZoteroLibrary implements IZoteroLibrary {
    type!: LibraryType;
    id!: number;
    name!: string;
    links!: LinkCollection;

    constructor(data?: IZoteroLibrary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.links = new LinkCollection();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.links = _data["links"] ? LinkCollection.fromJS(_data["links"]) : new LinkCollection();
        }
    }

    static fromJS(data: any): ZoteroLibrary {
        data = typeof data === 'object' ? data : {};
        let result = new ZoteroLibrary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["links"] = this.links ? this.links.toJSON() : <any>null;
        return data; 
    }
}

export interface IZoteroLibrary {
    type: LibraryType;
    id: number;
    name: string;
    links: LinkCollection;
}

export enum LibraryType {
    User = "User",
}

export class LinkCollection implements ILinkCollection {
    alternate!: Link;
    up!: Link;
    self!: Link;

    constructor(data?: ILinkCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.alternate = new Link();
            this.up = new Link();
            this.self = new Link();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alternate = _data["alternate"] ? Link.fromJS(_data["alternate"]) : new Link();
            this.up = _data["up"] ? Link.fromJS(_data["up"]) : new Link();
            this.self = _data["self"] ? Link.fromJS(_data["self"]) : new Link();
        }
    }

    static fromJS(data: any): LinkCollection {
        data = typeof data === 'object' ? data : {};
        let result = new LinkCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["alternate"] = this.alternate ? this.alternate.toJSON() : <any>null;
        data["up"] = this.up ? this.up.toJSON() : <any>null;
        data["self"] = this.self ? this.self.toJSON() : <any>null;
        return data; 
    }
}

export interface ILinkCollection {
    alternate: Link;
    up: Link;
    self: Link;
}

export class Link implements ILink {
    href!: string;
    type!: string;

    constructor(data?: ILink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.href = _data["href"] !== undefined ? _data["href"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
        }
    }

    static fromJS(data: any): Link {
        data = typeof data === 'object' ? data : {};
        let result = new Link();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href !== undefined ? this.href : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        return data; 
    }
}

export interface ILink {
    href: string;
    type: string;
}

export class Meta implements IMeta {
    numCollections!: number;
    numItems!: number;
    creatorSummary!: string;
    parsedDate!: string;

    constructor(data?: IMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numCollections = _data["numCollections"] !== undefined ? _data["numCollections"] : <any>null;
            this.numItems = _data["numItems"] !== undefined ? _data["numItems"] : <any>null;
            this.creatorSummary = _data["creatorSummary"] !== undefined ? _data["creatorSummary"] : <any>null;
            this.parsedDate = _data["parsedDate"] !== undefined ? _data["parsedDate"] : <any>null;
        }
    }

    static fromJS(data: any): Meta {
        data = typeof data === 'object' ? data : {};
        let result = new Meta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numCollections"] = this.numCollections !== undefined ? this.numCollections : <any>null;
        data["numItems"] = this.numItems !== undefined ? this.numItems : <any>null;
        data["creatorSummary"] = this.creatorSummary !== undefined ? this.creatorSummary : <any>null;
        data["parsedDate"] = this.parsedDate !== undefined ? this.parsedDate : <any>null;
        return data; 
    }
}

export interface IMeta {
    numCollections: number;
    numItems: number;
    creatorSummary: string;
    parsedDate: string;
}

export class ZoteroItem implements IZoteroItem {
    key!: string;
    version!: number;
    name!: string;
    parentCollection?: string | null;
    relations?: Relations | null;
    parentItem?: string | null;
    itemType?: ItemType | null;
    note?: string | null;
    tags?: any[] | null;
    dateAdded?: Date | null;
    dateModified?: Date | null;
    linkMode?: LinkMode | null;
    title?: string | null;
    accessDate?: string | null;
    url?: string | null;
    contentType?: string | null;
    charset?: string | null;
    path?: string | null;
    filename?: string | null;
    md5?: any | null;
    mtime?: any | null;
    creators?: Creator[] | null;
    abstractNote?: string | null;
    websiteTitle?: string | null;
    websiteType?: string | null;
    date?: string | null;
    shortTitle!: string;
    language?: string | null;
    rights?: string | null;
    extra?: string | null;
    collections!: string[];
    publicationTitle!: string;
    volume!: string;
    issue!: string;
    pages!: string;
    series?: string | null;
    seriesTitle!: string;
    seriesText!: string;
    journalAbbreviation!: string;
    doi!: string;
    issn!: string;
    archive!: string;
    archiveLocation!: string;
    libraryCatalog!: string;
    callNumber?: string | null;
    seriesNumber!: string;
    numberOfVolumes!: string;
    edition?: string | null;
    place!: string;
    publisher!: string;
    numPages!: string;
    isbn!: string;
    proceedingsTitle!: string;
    conferenceName!: string;

    constructor(data?: IZoteroItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.collections = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.parentCollection = _data["parentCollection"] !== undefined ? _data["parentCollection"] : <any>null;
            this.relations = _data["relations"] ? Relations.fromJS(_data["relations"]) : <any>null;
            this.parentItem = _data["parentItem"] !== undefined ? _data["parentItem"] : <any>null;
            this.itemType = _data["itemType"] !== undefined ? _data["itemType"] : <any>null;
            this.note = _data["note"] !== undefined ? _data["note"] : <any>null;
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            else {
                this.tags = <any>null;
            }
            this.dateAdded = _data["dateAdded"] ? new Date(_data["dateAdded"].toString()) : <any>null;
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>null;
            this.linkMode = _data["linkMode"] !== undefined ? _data["linkMode"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.accessDate = _data["accessDate"] !== undefined ? _data["accessDate"] : <any>null;
            this.url = _data["url"] !== undefined ? _data["url"] : <any>null;
            this.contentType = _data["contentType"] !== undefined ? _data["contentType"] : <any>null;
            this.charset = _data["charset"] !== undefined ? _data["charset"] : <any>null;
            this.path = _data["path"] !== undefined ? _data["path"] : <any>null;
            this.filename = _data["filename"] !== undefined ? _data["filename"] : <any>null;
            this.md5 = _data["md5"] !== undefined ? _data["md5"] : <any>null;
            this.mtime = _data["mtime"] !== undefined ? _data["mtime"] : <any>null;
            if (Array.isArray(_data["creators"])) {
                this.creators = [] as any;
                for (let item of _data["creators"])
                    this.creators!.push(Creator.fromJS(item));
            }
            else {
                this.creators = <any>null;
            }
            this.abstractNote = _data["abstractNote"] !== undefined ? _data["abstractNote"] : <any>null;
            this.websiteTitle = _data["websiteTitle"] !== undefined ? _data["websiteTitle"] : <any>null;
            this.websiteType = _data["websiteType"] !== undefined ? _data["websiteType"] : <any>null;
            this.date = _data["date"] !== undefined ? _data["date"] : <any>null;
            this.shortTitle = _data["shortTitle"] !== undefined ? _data["shortTitle"] : <any>null;
            this.language = _data["language"] !== undefined ? _data["language"] : <any>null;
            this.rights = _data["rights"] !== undefined ? _data["rights"] : <any>null;
            this.extra = _data["extra"] !== undefined ? _data["extra"] : <any>null;
            if (Array.isArray(_data["collections"])) {
                this.collections = [] as any;
                for (let item of _data["collections"])
                    this.collections!.push(item);
            }
            else {
                this.collections = <any>null;
            }
            this.publicationTitle = _data["publicationTitle"] !== undefined ? _data["publicationTitle"] : <any>null;
            this.volume = _data["volume"] !== undefined ? _data["volume"] : <any>null;
            this.issue = _data["issue"] !== undefined ? _data["issue"] : <any>null;
            this.pages = _data["pages"] !== undefined ? _data["pages"] : <any>null;
            this.series = _data["series"] !== undefined ? _data["series"] : <any>null;
            this.seriesTitle = _data["seriesTitle"] !== undefined ? _data["seriesTitle"] : <any>null;
            this.seriesText = _data["seriesText"] !== undefined ? _data["seriesText"] : <any>null;
            this.journalAbbreviation = _data["journalAbbreviation"] !== undefined ? _data["journalAbbreviation"] : <any>null;
            this.doi = _data["doi"] !== undefined ? _data["doi"] : <any>null;
            this.issn = _data["issn"] !== undefined ? _data["issn"] : <any>null;
            this.archive = _data["archive"] !== undefined ? _data["archive"] : <any>null;
            this.archiveLocation = _data["archiveLocation"] !== undefined ? _data["archiveLocation"] : <any>null;
            this.libraryCatalog = _data["libraryCatalog"] !== undefined ? _data["libraryCatalog"] : <any>null;
            this.callNumber = _data["callNumber"] !== undefined ? _data["callNumber"] : <any>null;
            this.seriesNumber = _data["seriesNumber"] !== undefined ? _data["seriesNumber"] : <any>null;
            this.numberOfVolumes = _data["numberOfVolumes"] !== undefined ? _data["numberOfVolumes"] : <any>null;
            this.edition = _data["edition"] !== undefined ? _data["edition"] : <any>null;
            this.place = _data["place"] !== undefined ? _data["place"] : <any>null;
            this.publisher = _data["publisher"] !== undefined ? _data["publisher"] : <any>null;
            this.numPages = _data["numPages"] !== undefined ? _data["numPages"] : <any>null;
            this.isbn = _data["isbn"] !== undefined ? _data["isbn"] : <any>null;
            this.proceedingsTitle = _data["proceedingsTitle"] !== undefined ? _data["proceedingsTitle"] : <any>null;
            this.conferenceName = _data["conferenceName"] !== undefined ? _data["conferenceName"] : <any>null;
        }
    }

    static fromJS(data: any): ZoteroItem {
        data = typeof data === 'object' ? data : {};
        let result = new ZoteroItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentCollection"] = this.parentCollection !== undefined ? this.parentCollection : <any>null;
        data["relations"] = this.relations ? this.relations.toJSON() : <any>null;
        data["parentItem"] = this.parentItem !== undefined ? this.parentItem : <any>null;
        data["itemType"] = this.itemType !== undefined ? this.itemType : <any>null;
        data["note"] = this.note !== undefined ? this.note : <any>null;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>null;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>null;
        data["linkMode"] = this.linkMode !== undefined ? this.linkMode : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["accessDate"] = this.accessDate !== undefined ? this.accessDate : <any>null;
        data["url"] = this.url !== undefined ? this.url : <any>null;
        data["contentType"] = this.contentType !== undefined ? this.contentType : <any>null;
        data["charset"] = this.charset !== undefined ? this.charset : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["filename"] = this.filename !== undefined ? this.filename : <any>null;
        data["md5"] = this.md5 !== undefined ? this.md5 : <any>null;
        data["mtime"] = this.mtime !== undefined ? this.mtime : <any>null;
        if (Array.isArray(this.creators)) {
            data["creators"] = [];
            for (let item of this.creators)
                data["creators"].push(item.toJSON());
        }
        data["abstractNote"] = this.abstractNote !== undefined ? this.abstractNote : <any>null;
        data["websiteTitle"] = this.websiteTitle !== undefined ? this.websiteTitle : <any>null;
        data["websiteType"] = this.websiteType !== undefined ? this.websiteType : <any>null;
        data["date"] = this.date !== undefined ? this.date : <any>null;
        data["shortTitle"] = this.shortTitle !== undefined ? this.shortTitle : <any>null;
        data["language"] = this.language !== undefined ? this.language : <any>null;
        data["rights"] = this.rights !== undefined ? this.rights : <any>null;
        data["extra"] = this.extra !== undefined ? this.extra : <any>null;
        if (Array.isArray(this.collections)) {
            data["collections"] = [];
            for (let item of this.collections)
                data["collections"].push(item);
        }
        data["publicationTitle"] = this.publicationTitle !== undefined ? this.publicationTitle : <any>null;
        data["volume"] = this.volume !== undefined ? this.volume : <any>null;
        data["issue"] = this.issue !== undefined ? this.issue : <any>null;
        data["pages"] = this.pages !== undefined ? this.pages : <any>null;
        data["series"] = this.series !== undefined ? this.series : <any>null;
        data["seriesTitle"] = this.seriesTitle !== undefined ? this.seriesTitle : <any>null;
        data["seriesText"] = this.seriesText !== undefined ? this.seriesText : <any>null;
        data["journalAbbreviation"] = this.journalAbbreviation !== undefined ? this.journalAbbreviation : <any>null;
        data["doi"] = this.doi !== undefined ? this.doi : <any>null;
        data["issn"] = this.issn !== undefined ? this.issn : <any>null;
        data["archive"] = this.archive !== undefined ? this.archive : <any>null;
        data["archiveLocation"] = this.archiveLocation !== undefined ? this.archiveLocation : <any>null;
        data["libraryCatalog"] = this.libraryCatalog !== undefined ? this.libraryCatalog : <any>null;
        data["callNumber"] = this.callNumber !== undefined ? this.callNumber : <any>null;
        data["seriesNumber"] = this.seriesNumber !== undefined ? this.seriesNumber : <any>null;
        data["numberOfVolumes"] = this.numberOfVolumes !== undefined ? this.numberOfVolumes : <any>null;
        data["edition"] = this.edition !== undefined ? this.edition : <any>null;
        data["place"] = this.place !== undefined ? this.place : <any>null;
        data["publisher"] = this.publisher !== undefined ? this.publisher : <any>null;
        data["numPages"] = this.numPages !== undefined ? this.numPages : <any>null;
        data["isbn"] = this.isbn !== undefined ? this.isbn : <any>null;
        data["proceedingsTitle"] = this.proceedingsTitle !== undefined ? this.proceedingsTitle : <any>null;
        data["conferenceName"] = this.conferenceName !== undefined ? this.conferenceName : <any>null;
        return data; 
    }
}

export interface IZoteroItem {
    key: string;
    version: number;
    name: string;
    parentCollection?: string | null;
    relations?: Relations | null;
    parentItem?: string | null;
    itemType?: ItemType | null;
    note?: string | null;
    tags?: any[] | null;
    dateAdded?: Date | null;
    dateModified?: Date | null;
    linkMode?: LinkMode | null;
    title?: string | null;
    accessDate?: string | null;
    url?: string | null;
    contentType?: string | null;
    charset?: string | null;
    path?: string | null;
    filename?: string | null;
    md5?: any | null;
    mtime?: any | null;
    creators?: Creator[] | null;
    abstractNote?: string | null;
    websiteTitle?: string | null;
    websiteType?: string | null;
    date?: string | null;
    shortTitle: string;
    language?: string | null;
    rights?: string | null;
    extra?: string | null;
    collections: string[];
    publicationTitle: string;
    volume: string;
    issue: string;
    pages: string;
    series?: string | null;
    seriesTitle: string;
    seriesText: string;
    journalAbbreviation: string;
    doi: string;
    issn: string;
    archive: string;
    archiveLocation: string;
    libraryCatalog: string;
    callNumber?: string | null;
    seriesNumber: string;
    numberOfVolumes: string;
    edition?: string | null;
    place: string;
    publisher: string;
    numPages: string;
    isbn: string;
    proceedingsTitle: string;
    conferenceName: string;
}

export class Relations implements IRelations {

    constructor(data?: IRelations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Relations {
        data = typeof data === 'object' ? data : {};
        let result = new Relations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IRelations {
}

export enum ItemType {
    Book = "Book",
    Artwork = "Artwork",
    AudioRecording = "AudioRecording",
    Bill = "Bill",
    BlogPost = "BlogPost",
    BookSection = "BookSection",
    Case = "Case",
    ConferencePaper = "ConferencePaper",
    DictionaryEntry = "DictionaryEntry",
    Document = "Document",
    Email = "Email",
    EncyclopediaArticle = "EncyclopediaArticle",
    Film = "Film",
    ForumPost = "ForumPost",
    Hearing = "Hearing",
    InstantMessage = "InstantMessage",
    Interview = "Interview",
    JournalArticle = "JournalArticle",
    Letter = "Letter",
    MagazineArticle = "MagazineArticle",
    Manuscript = "Manuscript",
    Map = "Map",
    NewspaperArticle = "NewspaperArticle",
    Patent = "Patent",
    Podcast = "Podcast",
    Presentation = "Presentation",
    RadioBroadcast = "RadioBroadcast",
    Report = "Report",
    Software = "Software",
    Statute = "Statute",
    Thesis = "Thesis",
    TVBroadcast = "TVBroadcast",
    VideoRecording = "VideoRecording",
    Webpage = "Webpage",
    Attachment = "Attachment",
    Note = "Note",
}

export enum LinkMode {
    Linked_file = "Linked_file",
    Imported_Url = "Imported_Url",
    Linked_url = "Linked_url",
    Imported_file = "Imported_file",
}

export class Creator implements ICreator {
    creatorType!: CreatorType;
    firstName!: string;
    lastName!: string;
    name!: string;

    constructor(data?: ICreator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.creatorType = _data["creatorType"] !== undefined ? _data["creatorType"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): Creator {
        data = typeof data === 'object' ? data : {};
        let result = new Creator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creatorType"] = this.creatorType !== undefined ? this.creatorType : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICreator {
    creatorType: CreatorType;
    firstName: string;
    lastName: string;
    name: string;
}

export enum CreatorType {
    Author = "Author",
    Editor = "Editor",
    SeriesEditor = "SeriesEditor",
    Translator = "Translator",
    ReviewedAuthor = "ReviewedAuthor",
}

export class ZoteroReturnDataOfZoteroCollection implements IZoteroReturnDataOfZoteroCollection {
    key!: string;
    version!: number;
    library!: ZoteroLibrary;
    links!: LinkCollection;
    meta!: Meta;
    data!: ZoteroCollection;

    constructor(data?: IZoteroReturnDataOfZoteroCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.library = new ZoteroLibrary();
            this.links = new LinkCollection();
            this.meta = new Meta();
            this.data = new ZoteroCollection();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.library = _data["library"] ? ZoteroLibrary.fromJS(_data["library"]) : new ZoteroLibrary();
            this.links = _data["links"] ? LinkCollection.fromJS(_data["links"]) : new LinkCollection();
            this.meta = _data["meta"] ? Meta.fromJS(_data["meta"]) : new Meta();
            this.data = _data["data"] ? ZoteroCollection.fromJS(_data["data"]) : new ZoteroCollection();
        }
    }

    static fromJS(data: any): ZoteroReturnDataOfZoteroCollection {
        data = typeof data === 'object' ? data : {};
        let result = new ZoteroReturnDataOfZoteroCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["library"] = this.library ? this.library.toJSON() : <any>null;
        data["links"] = this.links ? this.links.toJSON() : <any>null;
        data["meta"] = this.meta ? this.meta.toJSON() : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IZoteroReturnDataOfZoteroCollection {
    key: string;
    version: number;
    library: ZoteroLibrary;
    links: LinkCollection;
    meta: Meta;
    data: ZoteroCollection;
}

export class ZoteroCollection implements IZoteroCollection {
    key!: string;
    version!: number;
    name!: string;
    parentCollection?: string | null;
    relations?: Relations | null;

    constructor(data?: IZoteroCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.parentCollection = _data["parentCollection"] !== undefined ? _data["parentCollection"] : <any>null;
            this.relations = _data["relations"] ? Relations.fromJS(_data["relations"]) : <any>null;
        }
    }

    static fromJS(data: any): ZoteroCollection {
        data = typeof data === 'object' ? data : {};
        let result = new ZoteroCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parentCollection"] = this.parentCollection !== undefined ? this.parentCollection : <any>null;
        data["relations"] = this.relations ? this.relations.toJSON() : <any>null;
        return data; 
    }
}

export interface IZoteroCollection {
    key: string;
    version: number;
    name: string;
    parentCollection?: string | null;
    relations?: Relations | null;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}